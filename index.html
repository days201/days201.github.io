<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daya Silverstein â€” Mechanical Engineering @ Queen's University</title>
  <meta name="description" content="Portfolio of Daya Silverstein, Mechanical Engineering student at Queen's University. Projects in sustainable design, HVAC interest, FEA simulation, and CAD." />
  <link rel="icon" type="image/png" href="favicon.png?v=1">

  <!-- Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">

  <!-- Open Graph / Twitter for rich previews -->
  <meta property="og:title" content="Daya Silverstein â€” Mechanical Engineering" />
  <meta property="og:description" content="Sustainable design, CAD automation, and handsâ€‘on builds." />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="/assets/og-cover.png" />
  <meta name="twitter:card" content="summary_large_image" />

  <style>
    :root{
      --bg: #f8fafc;
      --card: #ffffff;
      --ink: #0f172a; /* deeper contrast for better readability */
      --muted: #475569;
      --brand: #3b82f6;
      --brand-light: #60a5fa;
      --accent: #10b981;
      --accent-light: #34d399;
      --accent2: #f59e0b;
      --accent2-light: #fbbf24;
      --ring: rgba(59,130,246,.25);
      --ring-accent: rgba(16,185,129,.25);
      --radius: 18px;
      --shadow: 0 10px 40px rgba(15,23,42,.08);
      --shadow-lg: 0 20px 60px rgba(15,23,42,.12);
      --hover: translateY(-4px);
      --hero-glow-x: 50%;
      --hero-glow-y: 50%;
      --border: #e2e8f0;
      --border-light: #f1f5f9;
      --chip-bg: #ffffff;
      --glass: rgba(255,255,255,.85);
    }
    @media (prefers-color-scheme: dark){
      :root{
        --bg: #0f172a;
        --card: #1e293b;
        --ink: #f1f5f9;
        --muted: #94a3b8;
        --brand: #60a5fa;
        --brand-light: #93c5fd;
        --accent: #34d399;
        --accent-light: #6ee7b7;
        --accent2: #fbbf24;
        --accent2-light: #fcd34d;
        --ring: rgba(96,165,250,.3);
        --ring-accent: rgba(52,211,153,.3);
        --shadow: 0 15px 50px rgba(0,0,0,.4);
        --shadow-lg: 0 25px 80px rgba(0,0,0,.5);
        --border: #334155;
        --border-light: #475569;
        --chip-bg: #1e293b;
        --glass: rgba(30,41,59,.9);
      }
    }

    /* Global */
    *{box-sizing:border-box}
    html, body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;min-height:100%;width:100%;overflow-x:hidden;font-weight:400;line-height:1.6}
    html{scroll-behavior:smooth}
    img,canvas,video{max-width:100%;height:auto;display:block}

    a{color:var(--brand);text-decoration:none;background-image:linear-gradient(var(--brand-light),var(--brand-light));background-size:0% 2px;background-repeat:no-repeat;background-position:0 100%;transition:background-size .3s ease, color .2s ease}
    a:hover{background-size:100% 2px;color:var(--brand-light)}

    .container{max-width:1200px;margin:0 auto;padding:clamp(20px,4vw,40px)}

    /* Hero */
    .hero{position:relative;display:grid;grid-template-columns:1.1fr .9fr;gap:40px;align-items:center;margin:80px 0 20px}
    .hero::before{content:"";position:absolute;inset:-60%;background:radial-gradient(800px 500px at var(--hero-glow-x) var(--hero-glow-y), rgba(59,130,246,.08), rgba(16,185,129,.04) 40%, transparent 70%);pointer-events:none;z-index:0;transition:opacity .3s ease}

    .badge{display:inline-block;background:linear-gradient(135deg,var(--brand),var(--brand-light),var(--accent));color:#fff;padding:8px 16px;border-radius:999px;font-weight:600;font-size:13px;letter-spacing:.5px;box-shadow:var(--shadow);border:1px solid rgba(255,255,255,.2)}
    h1{font-size:clamp(38px,5vw,56px);line-height:1.1;margin:16px 0 12px;font-weight:700;background:linear-gradient(135deg,var(--ink),var(--muted));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .subtitle{color:var(--muted);font-size:clamp(17px,2vw,20px);line-height:1.7;font-weight:400}

    .cta{display:flex;gap:16px;margin-top:24px;flex-wrap:wrap}
    .btn{position:relative;isolation:isolate;display:inline-flex;align-items:center;gap:12px;background:var(--glass);backdrop-filter:saturate(1.1) blur(10px);border:1px solid var(--border-light);border-radius:16px;padding:12px 20px;font-weight:600;box-shadow:var(--shadow);color:var(--brand);transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;font-size:15px}
    .btn::after{content:"";position:absolute;inset:-2px;border-radius:18px;box-shadow:0 0 0 0 var(--ring);opacity:0;transition:box-shadow .3s ease, opacity .3s ease;z-index:-1}
    .btn:hover{transform:translateY(-3px);border-color:var(--brand);background:rgba(255,255,255,.95)}
    .btn:hover::after{opacity:1;box-shadow:0 0 0 8px var(--ring)}
    .btn.primary{background:linear-gradient(135deg,var(--brand),var(--brand-light),var(--accent));color:#fff;border-color:transparent;box-shadow:var(--shadow-lg)}
    .btn.primary:hover{background:linear-gradient(135deg,var(--brand-light),var(--accent),var(--accent-light));transform:translateY(-4px)}

    /* Sections */
    .section{margin:60px 0}
    .section h2{font-size:32px;margin:0 0 20px;font-weight:700;background:linear-gradient(135deg,var(--ink),var(--muted));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}

    /* Cards */
    .grid{display:grid;gap:24px}
    .cards{grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}

    /* Micro tilt */
    .tilt{perspective:1000px;transform-style:preserve-3d}
    .tilt:hover{transform:perspective(1000px) rotateX(var(--rx,0deg)) rotateY(var(--ry,0deg))}

    /* Thumbs */
    .thumb{width:100%;height:180px;border-radius:16px;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;letter-spacing:.4px;text-transform:uppercase;position:relative;overflow:hidden;text-align:center;padding:0 16px;z-index:0;box-shadow:var(--shadow-lg);transition:all .4s cubic-bezier(0.4, 0, 0.2, 1)}
    .thumb > *{position:relative;z-index:1;text-shadow:0 2px 10px rgba(0,0,0,.4);transition:transform .4s cubic-bezier(0.4, 0, 0.2, 1)}
    .thumb:hover{transform:scale(1.02);box-shadow:0 25px 80px rgba(0,0,0,.2)}
    .thumb:hover > *{transform:scale(1.05)}

    /* Enhanced text highlight that matches text width */
    .thumb .thumb-label{position:relative;display:inline-block;padding:0 .15em;z-index:1}
    .thumb .thumb-label::after{content:"";position:absolute;left:0;right:0;bottom:.1em;height:.7em;border-radius:8px;background:rgba(255,255,255,.18);z-index:-1}

    /* Themed thumbs */
    .thumb.water{background:radial-gradient(60% 100% at 20% 0%, rgba(255,255,255,.3) 0 50%, transparent 51%),radial-gradient(40% 80% at 90% 30%, rgba(255,255,255,.2) 0 50%, transparent 51%),linear-gradient(135deg,#0ea5e9,var(--brand),var(--accent) 80%)}
    .thumb.path{background:linear-gradient(135deg,#1e293b,#334155,#475569)}
    .thumb.cad{background:radial-gradient(250px 250px at 85% 20%, rgba(255,255,255,.4) 0 140px, transparent 141px),linear-gradient(135deg,var(--brand),var(--brand-light),var(--accent))}

    /* Skill levels */
    .skill-item{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
    .skill-name{font-weight:600;color:var(--ink);min-width:100px}
    .skill-level{flex:1;height:8px;background:var(--border-light);border-radius:4px;margin:0 12px;overflow:hidden}
    .skill-bar{height:100%;background:linear-gradient(90deg,var(--brand),var(--accent));border-radius:4px;transition:width .6s ease}
    .skill-label{font-size:13px;color:var(--muted);min-width:80px;text-align:right}

    /* Lists */
    ul.clean{list-style:none;padding:0;margin:0}
    ul.clean li{margin:12px 0;color:var(--muted);line-height:1.6}

    /* Chips */
    .chips{display:flex;flex-wrap:wrap;gap:10px}

    /* Footer */
    footer{margin:60px 0 32px;color:var(--muted);font-size:14px;text-align:center;font-weight:500}

    /* Floating theme toggle */
    .theme-toggle{
      position:fixed;
      top:24px;
      right:24px;
      z-index:100;
      display:inline-flex;
      align-items:center;
      gap:10px;
      border:1px solid var(--border-light);
      border-radius:999px;
      padding:10px 16px;
      background:var(--glass);
      backdrop-filter:saturate(1.2) blur(12px);
      color:var(--ink);
      box-shadow:var(--shadow-lg);
      transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
    }
    .theme-toggle:hover{
      transform:translateY(-2px);
      box-shadow:0 20px 60px rgba(0,0,0,.15);
      border-color:var(--accent);
    }
    .theme-toggle button{
      appearance:none;
      border:0;
      background:transparent;
      color:inherit;
      font:inherit;
      cursor:pointer;
      padding:4px;
      font-size:18px;
      transition:transform .2s ease;
      border-radius:8px;
    }
    .theme-toggle button:hover{
      transform:scale(1.15);
      background:rgba(255,255,255,.1);
    }

    /* Scroll progress indicator */
    .scroll-progress{
      position:fixed;
      top:0;
      left:0;
      height:3px;
      background:linear-gradient(90deg,var(--brand),var(--accent));
      width:0%;
      z-index:1000;
      transition:width .1s ease;
      box-shadow:0 0 10px rgba(59,130,246,.3);
    }

    /* Enhanced animations */
    .fade{opacity:0;transform:translateY(20px);transition:opacity .8s cubic-bezier(0.4, 0, 0.2, 1), transform .8s cubic-bezier(0.4, 0, 0.2, 1)}
    .fade.in{opacity:1;transform:translateY(0)}
    .fade2{transition-delay:.3s}
    .reveal{opacity:0;transform:translateY(30px);transition:opacity 1s cubic-bezier(0.4, 0, 0.2, 1), transform 1s cubic-bezier(0.4, 0, 0.2, 1)}
    .reveal.in{opacity:1;transform:translateY(0)}

    /* Enhanced hero section */
    .hero::after{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg, transparent, var(--accent), transparent);opacity:0.3}

    /* Enhanced card hover effects */
    .card{background:var(--glass);backdrop-filter:saturate(1.1) blur(10px);border-radius:var(--radius);box-shadow:var(--shadow);padding:24px;border:1px solid var(--border-light);transition:all .4s cubic-bezier(0.4, 0, 0.2, 1);position:relative;overflow:hidden}
    .card::before{content:"";position:absolute;top:0;left:0;right:0;height:1px;background:linear-gradient(90deg, transparent, var(--accent-light), transparent);opacity:0;transition:opacity .4s cubic-bezier(0.4, 0, 0.2, 1)}
    .card:hover{transform:translateY(-6px) scale(1.02);box-shadow:var(--shadow-lg);border-color:var(--accent);background:rgba(255,255,255,.98)}
    .card:hover::before{opacity:0.8}

    /* Enhanced chip animations */
    .chip{background:var(--glass);backdrop-filter:saturate(1.1) blur(8px);border:1px solid var(--border-light);border-radius:999px;padding:8px 14px;font-size:13px;font-weight:600;transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);text-decoration:none;color:var(--muted)}
    .chip:hover{transform:translateY(-3px) scale(1.05);border-color:var(--accent);box-shadow:var(--shadow);background:rgba(255,255,255,.95);color:var(--brand)}

    /* Accessibility helpers */
    .skip{position:absolute;left:-9999px;top:auto}
    .skip:focus{left:12px;top:12px;background:var(--card);border:2px solid var(--brand);padding:8px;border-radius:8px}

    /* Enhanced focus states */
    a:focus-visible, button:focus-visible, .btn:focus-visible{outline:2px solid var(--brand);outline-offset:2px;border-radius:8px}
    .card:focus-within{border-color:var(--accent);box-shadow:var(--shadow-lg)}

    /* Responsive improvements */
    @media (max-width: 900px){ 
      .hero{grid-template-columns:1fr} 
      .skill-item{flex-direction:column;align-items:flex-start;gap:4px}
      .skill-level{margin:4px 0}
      .skill-label{align-self:flex-end}
    }
    @media (max-width: 600px){ 
      .cta .btn{flex:1}
      .cards{grid-template-columns:1fr}
      .container{padding:16px}
      .card{padding:20px}
    }
    @media (max-width: 420px){ 
      .cta{flex-direction:column}
      .theme-toggle{top:16px;right:16px;padding:8px 12px}
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce){
      *{animation:none !important; transition:none !important}
      .card:hover,.btn:hover{transform:none !important}
      .hero::before{display:none}
      .skill-bar{transition:none}
    }
  </style>
</head>
<body>
  <a class="skip" href="#content">Skip to main content</a>

  <!-- Floating theme toggle -->
  <div class="theme-toggle" title="Toggle theme">
    <button id="modeBtn" aria-label="Toggle dark mode">ðŸŒ“</button>
  </div>

  <!-- Scroll progress indicator -->
  <div class="scroll-progress" id="scrollProgress"></div>

  <div class="container">
    <main id="content">

      <!-- Hero -->
      <section class="hero reveal">
        <div class="fade">
          <span class="badge">Mechanical Engineering student at Queen's</span>
          <h1>Hello, I'm Daya.</h1>
          <p class="subtitle">I'm a second-year Mechanical Engineering student passionate about creating sustainable designs that maximize efficiency, performance, and turn innovative ideas into practical solutions.</p>
          <div class="cta">
            <a class="btn magnet" href="#projects" aria-label="View projects">View Projects</a>
            <a class="btn magnet" href="mailto:daya.silverstein@queensu.ca" aria-label="Email Daya">Email me</a>
            <a class="btn primary" href="assets/DayasResume.pdf" download="Daya_Silverstein_Resume.pdf" aria-label="Download Resume">Download Resume</a>
          </div>
        </div>
        <div class="fade fade2">
          <div class="card tilt" aria-label="About me highlights">
            <h2 style="margin-top:0">In Summary</h2>
            <ul class="clean">
              <li><strong>Interests:</strong> Sustainable design, HVAC systems, FEA simulation</li>
              <li><strong>Strengths:</strong> Assembly coordination, CAD modeling, rapid prototyping</li>
              <li><strong>Looking for:</strong> Engineering internships and collaborative project teams</li>
            </ul>
            <div class="chips" style="margin-top:16px">
              <span class="chip">Fusion 360</span>
              <span class="chip">SolidWorks</span>
              <span class="chip">MATLAB</span>
              <span class="chip">Arduino</span>
            </div>
          </div>
        </div>
      </section>

      <!-- Projects -->
      <section id="projects" class="section reveal">
        <h2>Featured Projects</h2>
        <div class="grid cards">
          <article class="card tilt reveal">
            <div class="thumb water" aria-label="Water filtration system project with flowing water animation"><span class="thumb-label">Water Filtration System</span></div>
            <h3 style="margin:12px 0 6px">Water Filtration System</h3>
            <p class="subtitle">Designed and manufactured the mixing assembly; coordinated overall assembly and Arduino timing controls.</p>
            <ul class="clean">
              <li><strong>Challenge:</strong> Produce potable water from contaminated input using a single, compact system.</li>
              <li><strong>Solution:</strong> Peristaltic pump + DC motor mixing with alum, followed by mechanical filtration; custom 3Dâ€‘printed components.</li>
              <li><strong>Outcome:</strong> Successfully deployed working prototype with automated timing.</li>
              <li><strong>Status:</strong> Completed â€¢ January 2025</li>
            </ul>
            <div class="chips"><span class="chip">Arduino</span><span class="chip">3D printing</span><span class="chip">Peristaltic pump</span><span class="chip">Water treatment</span></div>
          </article>

          <article class="card tilt reveal">
            <div class="thumb path" aria-label="Path planning visualization with animated routes"><span class="thumb-label">Pathâ€‘Planning</span></div>
            <h3 style="margin:12px 0 6px">Autonomous Pathâ€‘Planning for Warehouse Robots</h3>
            <p class="subtitle">A* pathfinding algorithm with MATLAB simulation to navigate checkpoints while avoiding dynamic obstacles.</p>
            <ul class="clean">
              <li><strong>Challenge:</strong> Plan optimal, collisionâ€‘free routes through warehouse environments with constraints.</li>
              <li><strong>Solution:</strong> Implemented A* algorithm with heuristic optimization; comprehensive MATLAB simulation environment.</li>
              <li><strong>Outcome:</strong> Robust pathfinding system capable of real-time route optimization.</li>
              <li><strong>Status:</strong> Completed â€¢ January 2025</li>
            </ul>
            <div class="chips"><span class="chip">A* Algorithm</span><span class="chip">MATLAB</span><span class="chip">Robotics</span></div>
            <div style="margin-top:12px"><a href="https://github.com/mohammedz06/Autonomous-Path-Finding" target="_blank" rel="noopener">View repository â†’</a></div>
          </article>

          <article class="card tilt reveal">
            <div class="thumb cad" aria-label="CAD automation with animated gears"><span class="thumb-label">Fusion Assembly Generator</span></div>
            <h3 style="margin:12px 0 6px">Fusion Assembly Generator</h3>
            <p class="subtitle">AI-powered tool that converts naturalâ€‘language prompts into executable Fusion 360 scripts for mechanical assemblies.</p>
            <ul class="clean">
              <li><strong>Challenge:</strong> Bridge the gap between design intent and executable CAD through automation.</li>
              <li><strong>Solution:</strong> Python addâ€‘in leveraging Fusion 360 API with intelligent schema parsing.</li>
              <li><strong>Status:</strong> In Development â€¢ Est. completion March 2025</li>
            </ul>
            <div class="chips"><span class="chip">Python</span><span class="chip">Fusion API</span><span class="chip">AI Integration</span><span class="chip">CAD Automation</span></div>
            <div style="margin-top:12px"><a href="https://github.com/days201/Fusion_Assembly_Generator" target="_blank" rel="noopener">View repository â†’</a></div>
          </article>
        </div>
      </section>

      <!-- Skills -->
      <section id="skills" class="section reveal">
        <h2>Technical Skills</h2>
        <div class="grid cards" style="grid-template-columns:repeat(auto-fit,minmax(280px,1fr))">
          <div class="card tilt reveal">
            <h3 style="margin-top:0">CAD & Design</h3>
            <div class="skill-item">
              <span class="skill-name">Fusion 360</span>
              <div class="skill-level"><div class="skill-bar" style="width: 65%"></div></div>
              <span class="skill-label">Intermediate</span>
            </div>
            <div class="skill-item">
              <span class="skill-name">SolidWorks</span>
              <div class="skill-level"><div class="skill-bar" style="width: 55%"></div></div>
              <span class="skill-label">Basics+</span>
            </div>
            <div class="skill-item">
              <span class="skill-name">Revit</span>
              <div class="skill-level"><div class="skill-bar" style="width: 45%"></div></div>
              <span class="skill-label">Basics</span>
            </div>
          </div>
          <div class="card tilt reveal">
            <h3 style="margin-top:0">Analysis & Simulation</h3>
            <div class="skill-item">
              <span class="skill-name">MATLAB</span>
              <div class="skill-level"><div class="skill-bar" style="width: 65%"></div></div>
              <span class="skill-label">Intermediate</span>
            </div>
            <div class="skill-item">
              <span class="skill-name">FEA/CFD</span>
              <div class="skill-level"><div class="skill-bar" style="width: 25%"></div></div>
              <span class="skill-label">Basics</span>
            </div>
          </div>
          <div class="card tilt reveal">
            <h3 style="margin-top:0">Fabrication & Controls</h3>
            <div class="skill-item">
              <span class="skill-name">3D Printing</span>
              <div class="skill-level"><div class="skill-bar" style="width: 70%"></div></div>
              <span class="skill-label">Intermediate+</span>
            </div>
            <div class="skill-item">
              <span class="skill-name">Arduino</span>
              <div class="skill-level"><div class="skill-bar" style="width: 55%"></div></div>
              <span class="skill-label">Basics+</span>
            </div>
            <div class="skill-item">
              <span class="skill-name">GD&T</span>
              <div class="skill-level"><div class="skill-bar" style="width: 45%"></div></div>
              <span class="skill-label">Basics</span>
            </div>
          </div>
        </div>
      </section>

      <!-- Experience -->
      <section id="experience" class="section reveal">
        <h2>Experience & Leadership</h2>
        <div class="grid" style="grid-template-columns:1fr">
          <article class="card tilt reveal">
            <h3 style="margin-top:0">Volunteer Tutor â€” CTA Dropâ€‘in Tutoring Club</h3>
            <p class="subtitle">Mathematics & Sciences â€¢ September 2023 â€“ June 2024</p>
            <ul class="clean">
              <li>Provided academic support to students in core STEM subjects, adapting teaching methods to individual learning styles</li>
              <li>Developed clear explanations for complex engineering and mathematical concepts</li>
              <li>Collaborated with fellow tutors to create effective study resources and problem-solving strategies</li>
            </ul>
            <div class="chips" style="margin-top:12px">
              <span class="chip">Mentoring</span>
              <span class="chip">STEM Education</span>
              <span class="chip">Communication</span>
            </div>
          </article>
        </div>
      </section>

      <!-- Contact -->
      <section id="contact" class="section reveal">
        <h2>Let's Connect</h2>
        <div class="card tilt reveal">
          <p style="margin-top:0">I'm always interested in discussing engineering projects, internship opportunities, or innovative design challenges.</p>
          <p>
            <a class="btn primary magnet" href="mailto:daya.silverstein@queensu.ca" aria-label="send email">daya.silverstein@queensu.ca</a>
          </p>
          <div class="chips" style="margin-top:16px">
            <a class="chip" href="https://github.com/days201" target="_blank" rel="noopener" aria-label="GitHub Profile">GitHub</a>
            <a class="chip" href="https://www.linkedin.com/in/" target="_blank" rel="noopener" aria-label="LinkedIn Profile">LinkedIn</a>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <div>Â© <span id="y"></span> Daya Silverstein â€¢ Built with modern web technologies</div>
    </footer>
  </div>

  <script>
    // Respect saved theme toggle
    (function(){
      const pref = localStorage.getItem('mode');
      if(pref === 'dark') document.documentElement.style.colorScheme = 'dark';
      if(pref === 'light') document.documentElement.style.colorScheme = 'light';
    })();

    // Year
    document.getElementById('y').textContent = new Date().getFullYear();

    const mediaReduce = window.matchMedia('(prefers-reduced-motion: reduce)');

    // Cursor-follow glow in hero
    const hero = document.querySelector('.hero');
    if(hero && !mediaReduce.matches){
      hero.addEventListener('pointermove', (e)=>{
        const r = hero.getBoundingClientRect();
        const x = ((e.clientX - r.left)/r.width)*100 + '%';
        const y = ((e.clientY - r.top)/r.height)*100 + '%';
        hero.style.setProperty('--hero-glow-x', x);
        hero.style.setProperty('--hero-glow-y', y);
      });
    }

    // Reveal on scroll with intersection observer
    document.addEventListener('DOMContentLoaded', function() {
      const io = new IntersectionObserver((entries)=>{
        entries.forEach(entry=>{
          if(entry.isIntersecting){ 
            entry.target.classList.add('in'); 
            // Animate skill bars when they come into view
            if(entry.target.querySelector('.skill-bar')){
              setTimeout(() => {
                entry.target.querySelectorAll('.skill-bar').forEach(bar => {
                  bar.style.width = bar.style.width || '0%';
                });
              }, 200);
            }
            io.unobserve(entry.target); 
          }
        });
      },{threshold:.12});
      
      document.querySelectorAll('.reveal, .fade').forEach(el=> io.observe(el));
    });

    // Magnetic buttons (subtle)
    document.querySelectorAll('.magnet').forEach(btn=>{
      if(mediaReduce.matches) return;
      btn.addEventListener('pointermove', (e)=>{
        const r = btn.getBoundingClientRect();
        const mx = e.clientX - (r.left + r.width/2);
        const my = e.clientY - (r.top + r.height/2);
        btn.style.transform = `translate(${mx/14}px, ${my/14}px)`; // subtle
      });
      btn.addEventListener('pointerleave', ()=>{ btn.style.transform = ''; });
    });

    // Micro tilt on cards
    const tilts = document.querySelectorAll('.tilt');
    tilts.forEach(card=>{
      if(mediaReduce.matches) return;
      card.addEventListener('pointermove', (e)=>{
        const r = card.getBoundingClientRect();
        const rx = ((e.clientY - r.top) / r.height - .5) * -3; // degrees
        const ry = ((e.clientX - r.left) / r.width - .5) * 3;
        card.style.setProperty('--rx', rx + 'deg');
        card.style.setProperty('--ry', ry + 'deg');
      });
      card.addEventListener('pointerleave', ()=>{
        card.style.removeProperty('--rx');
        card.style.removeProperty('--ry');
      });
    });

    // Helpers to mount a canvas on a tile
    function mountCanvas(tile){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.style.position = 'absolute';
      canvas.style.inset = '0';
      canvas.style.zIndex = '0';
      canvas.setAttribute('aria-hidden','true');
      tile.appendChild(canvas);
      return {canvas, ctx};
    }

    // ===== Path tile animation (A* pathfinding simulation) =====
    (function(){
      const tiles = document.querySelectorAll('.thumb.path');
      if (!tiles.length) return;
      tiles.forEach(tile => {
        const {canvas, ctx} = mountCanvas(tile);
        let w=0,h=0, dpr=1, time=0;
        let grid = [], obstacles = [], paths = [], robots = [];
        const gridSize = 12;
        
        function resize(){
          const rect = tile.getBoundingClientRect();
          w = Math.floor(rect.width);
          h = Math.floor(rect.height);
          dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = w * dpr; canvas.height = h * dpr;
          canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
          ctx.setTransform(dpr,0,0,dpr,0,0);
          initWarehouse();
        }
        
        function initWarehouse(){
          // Create warehouse grid
          const cols = Math.floor(w / gridSize);
          const rows = Math.floor(h / gridSize);
          grid = Array(rows).fill().map(() => Array(cols).fill(0));
          obstacles = [];
          
          // Add warehouse obstacles (shelves, walls)
          const obstaclePositions = [
            {x: Math.floor(cols*0.25), y: Math.floor(rows*0.3), w: 2, h: 4},
            {x: Math.floor(cols*0.6), y: Math.floor(rows*0.2), w: 3, h: 2},
            {x: Math.floor(cols*0.4), y: Math.floor(rows*0.6), w: 2, h: 3},
            {x: Math.floor(cols*0.75), y: Math.floor(rows*0.7), w: 2, h: 2},
            {x: Math.floor(cols*0.15), y: Math.floor(rows*0.75), w: 3, h: 1},
          ];
          
          obstaclePositions.forEach(obs => {
            for(let y = obs.y; y < Math.min(obs.y + obs.h, rows); y++) {
              for(let x = obs.x; x < Math.min(obs.x + obs.w, cols); x++) {
                if(x >= 0 && y >= 0) {
                  grid[y][x] = 1;
                  obstacles.push({x: x * gridSize, y: y * gridSize});
                }
              }
            }
          });
          
          // Generate realistic A* paths
          paths = generateAStarPaths(cols, rows);
          
          // Initialize robots
          robots = [];
          for(let i = 0; i < 3; i++) {
            const pathIndex = i % paths.length;
            if(paths[pathIndex] && paths[pathIndex].length > 0) {
              robots.push({
                pathIndex,
                segmentIndex: 0,
                t: Math.random(),
                speed: 0.008 + Math.random() * 0.004,
                color: `hsl(${120 + i * 40}, 70%, 60%)`,
                size: 2.5 + Math.random() * 1
              });
            }
          }
        }
        
        function generateAStarPaths(cols, rows) {
          const paths = [];
          const startPoints = [
            {x: 1, y: Math.floor(rows/2)},
            {x: 1, y: Math.floor(rows*0.3)},
            {x: 1, y: Math.floor(rows*0.7)}
          ];
          const endPoints = [
            {x: cols-2, y: Math.floor(rows/2)},
            {x: cols-2, y: Math.floor(rows*0.4)},
            {x: cols-2, y: Math.floor(rows*0.6)}
          ];
          
          startPoints.forEach((start, i) => {
            const end = endPoints[i % endPoints.length];
            const path = findAStarPath(start, end, cols, rows);
            if(path) paths.push(path);
          });
          
          return paths;
        }
        
        function findAStarPath(start, goal, cols, rows) {
          const openSet = [{...start, g: 0, h: manhattanDistance(start, goal), f: manhattanDistance(start, goal), parent: null}];
          const closedSet = new Set();
          const visited = Array(rows).fill().map(() => Array(cols).fill(false));
          
          while(openSet.length > 0) {
            openSet.sort((a, b) => a.f - b.f);
            const current = openSet.shift();
            const key = `${current.x},${current.y}`;
            
            if(current.x === goal.x && current.y === goal.y) {
              // Reconstruct path
              const path = [];
              let node = current;
              while(node) {
                path.unshift({x: node.x, y: node.y});
                node = node.parent;
              }
              return path;
            }
            
            closedSet.add(key);
            
            // Check neighbors
            const neighbors = [
              {x: current.x + 1, y: current.y},
              {x: current.x - 1, y: current.y},
              {x: current.x, y: current.y + 1},
              {x: current.x, y: current.y - 1}
            ];
            
            neighbors.forEach(neighbor => {
              if(neighbor.x < 0 || neighbor.x >= cols || neighbor.y < 0 || neighbor.y >= rows) return;
              if(grid[neighbor.y] && grid[neighbor.y][neighbor.x] === 1) return; // obstacle
              
              const neighborKey = `${neighbor.x},${neighbor.y}`;
              if(closedSet.has(neighborKey)) return;
              
              const g = current.g + 1;
              const h = manhattanDistance(neighbor, goal);
              const f = g + h;
              
              const existingNode = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
              if(!existingNode) {
                openSet.push({...neighbor, g, h, f, parent: current});
              } else if(g < existingNode.g) {
                existingNode.g = g;
                existingNode.f = f;
                existingNode.parent = current;
              }
            });
          }
          
          return null; // No path found
        }
        
        function manhattanDistance(a, b) {
          return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        
        function frame(animated) {
          ctx.clearRect(0, 0, w, h);
          if(animated) time += 0.016;
          
          // Draw grid background
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.lineWidth = 0.5;
          for(let x = 0; x < w; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
          }
          for(let y = 0; y < h; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
          }
          
          // Draw obstacles (warehouse shelves)
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          obstacles.forEach(obs => {
            ctx.fillRect(obs.x + 1, obs.y + 1, gridSize - 2, gridSize - 2);
          });
          
          // Draw paths
          ctx.strokeStyle = 'rgba(52,211,153,0.3)';
          ctx.lineWidth = 2;
          paths.forEach(path => {
            if(path.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(path[0].x * gridSize + gridSize/2, path[0].y * gridSize + gridSize/2);
            for(let i = 1; i < path.length; i++) {
              ctx.lineTo(path[i].x * gridSize + gridSize/2, path[i].y * gridSize + gridSize/2);
            }
            ctx.stroke();
          });
          
          if(!animated) return;
          
          // Animate robots along paths
          robots.forEach(robot => {
            const path = paths[robot.pathIndex];
            if(!path || path.length < 2) return;
            
            const segment = robot.segmentIndex;
            if(segment >= path.length - 1) {
              robot.segmentIndex = 0;
              robot.t = 0;
              return;
            }
            
            const start = path[segment];
            const end = path[segment + 1];
            
            const x = (start.x + (end.x - start.x) * robot.t) * gridSize + gridSize/2;
            const y = (start.y + (end.y - start.y) * robot.t) * gridSize + gridSize/2;
            
            // Draw robot with trail effect
            ctx.fillStyle = robot.color;
            ctx.shadowColor = robot.color;
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(x, y, robot.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Update position
            robot.t += robot.speed;
            if(robot.t >= 1) {
              robot.t = 0;
              robot.segmentIndex++;
            }
          });
        }
        
        function animate() { 
          frame(true); 
          requestAnimationFrame(animate); 
        }
        
        function drawStatic() { 
          frame(false); 
        }
        
        resize();
        if (mediaReduce.matches) { 
          drawStatic(); 
        } else { 
          animate(); 
        }
        window.addEventListener('resize', resize);
      });
    })();

    // ===== Water tile animation (enhanced fluid simulation) =====
    (function(){
      const tiles = document.querySelectorAll('.thumb.water');
      if (!tiles.length) return;
      tiles.forEach(tile => {
        const {canvas, ctx} = mountCanvas(tile);
        let w=0,h=0, dpr=1, time=0;
        let droplets = [];
        
        function resize(){
          const rect = tile.getBoundingClientRect();
          w = Math.floor(rect.width);
          h = Math.floor(rect.height);
          dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = w * dpr; canvas.height = h * dpr;
          canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
          ctx.setTransform(dpr,0,0,dpr,0,0);
          initDroplets();
        }
        
        function initDroplets() {
          droplets = [];
          for(let i = 0; i < 8; i++) {
            droplets.push({
              x: Math.random() * w,
              y: Math.random() * h,
              vx: (Math.random() - 0.5) * 0.5,
              vy: (Math.random() - 0.5) * 0.5,
              size: 2 + Math.random() * 3,
              opacity: 0.3 + Math.random() * 0.4,
              phase: Math.random() * Math.PI * 2
            });
          }
        }
        
        function drawFrame(animated){
          ctx.clearRect(0,0,w,h);
          if (animated) time += 0.025;
          
          // Draw flowing waves with improved curves
          const waves = [
            {amplitude: 20, frequency: 0.015, speed: 1, offset: 0, opacity: 0.15, width: 3},
            {amplitude: 15, frequency: 0.022, speed: 0.8, offset: Math.PI/3, opacity: 0.12, width: 2.5},
            {amplitude: 12, frequency: 0.028, speed: 1.2, offset: Math.PI*2/3, opacity: 0.1, width: 2}
          ];
          
          waves.forEach((wave, i) => {
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255,255,255,${wave.opacity})`;
            ctx.lineWidth = wave.width;
            ctx.lineCap = 'round';
            
            const timeOffset = (animated ? time : 1) * wave.speed + wave.offset;
            const baseY = h/2 + Math.sin(timeOffset * 0.3) * 5;
            
            ctx.moveTo(0, baseY);
            for(let x = 0; x <= w; x += 1) {
              const y = baseY + Math.sin(x * wave.frequency + timeOffset) * wave.amplitude;
              ctx.lineTo(x, y);
            }
            ctx.stroke();
          });
          
          if(!animated) return;
          
          // Animate droplets with improved physics
          droplets.forEach(droplet => {
            // Update position with flow influence
            const flowInfluence = Math.sin(droplet.x * 0.01 + time * 0.8) * 0.2;
            droplet.x += droplet.vx + flowInfluence;
            droplet.y += droplet.vy + Math.sin(time + droplet.phase) * 0.1;
            
            // Boundary conditions with smooth wrapping
            if(droplet.x > w + 10) droplet.x = -10;
            if(droplet.x < -10) droplet.x = w + 10;
            if(droplet.y > h + 10) droplet.y = -10;
            if(droplet.y < -10) droplet.y = h + 10;
            
            // Draw droplet with gradient effect
            const gradient = ctx.createRadialGradient(
              droplet.x, droplet.y, 0,
              droplet.x, droplet.y, droplet.size
            );
            gradient.addColorStop(0, `rgba(255,255,255,${droplet.opacity})`);
            gradient.addColorStop(0.7, `rgba(255,255,255,${droplet.opacity * 0.5})`);
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(droplet.x, droplet.y, droplet.size, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // Add bubbles effect
          for(let i = 0; i < 5; i++) {
            const bubbleTime = time + i * Math.PI / 2;
            const x = (bubbleTime * 0.3 % 1) * w;
            const y = h/2 + Math.sin(bubbleTime * 2) * 25 + Math.sin(bubbleTime * 0.7) * 10;
            const size = 1.5 + Math.sin(bubbleTime * 3) * 1;
            const opacity = 0.2 + Math.sin(bubbleTime * 1.5) * 0.15;
            
            ctx.beginPath();
            ctx.fillStyle = `rgba(255,255,255,${opacity})`;
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        function animate(){ 
          drawFrame(true); 
          requestAnimationFrame(animate); 
        }
        
        resize();
        if (mediaReduce.matches){ 
          drawFrame(false); 
        } else { 
          animate(); 
        }
        window.addEventListener('resize', resize);
      });
    })();

    // ===== CAD gear animation (enhanced mechanical simulation) =====
    (function(){
      const tiles = document.querySelectorAll('.thumb.cad');
      if (!tiles.length) return;
      tiles.forEach(tile => {
        const {canvas, ctx} = mountCanvas(tile);
        let w=0,h=0, dpr=1, time=0;
        let sparkles = [];
        
        function resize(){
          const rect = tile.getBoundingClientRect();
          w = Math.floor(rect.width);
          h = Math.floor(rect.height);
          dpr = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = w * dpr; canvas.height = h * dpr;
          canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
          ctx.setTransform(dpr,0,0,dpr,0,0);
          initSparkles();
        }
        
        function initSparkles() {
          sparkles = [];
          for(let i = 0; i < 6; i++) {
            sparkles.push({
              x: Math.random() * w,
              y: Math.random() * h,
              size: 0.5 + Math.random() * 1.5,
              opacity: 0.2 + Math.random() * 0.4,
              phase: Math.random() * Math.PI * 2,
              speed: 0.02 + Math.random() * 0.02
            });
          }
        }
        
        function drawGear(x, y, radius, teeth, rotation, strokeOpacity = 0.15, fillOpacity = 0.05) {
          ctx.save(); 
          ctx.translate(x, y); 
          ctx.rotate(rotation);
          
          const innerRadius = radius * 0.65; 
          const toothHeight = radius * 0.25;
          const outerRadius = radius + toothHeight;
          
          // Draw gear body with gradient
          const gradient = ctx.createRadialGradient(0, 0, innerRadius, 0, 0, outerRadius);
          gradient.addColorStop(0, `rgba(255,255,255,${fillOpacity})`);
          gradient.addColorStop(1, 'rgba(255,255,255,0)');
          
          ctx.beginPath();
          for(let i = 0; i < teeth; i++){
            const angle1 = (i / teeth) * Math.PI * 2;
            const angle2 = ((i + 0.3) / teeth) * Math.PI * 2;
            const angle3 = ((i + 0.7) / teeth) * Math.PI * 2;
            const angle4 = ((i + 1) / teeth) * Math.PI * 2;
            
            const x1 = Math.cos(angle1) * radius; 
            const y1 = Math.sin(angle1) * radius;
            const x2 = Math.cos(angle2) * outerRadius; 
            const y2 = Math.sin(angle2) * outerRadius;
            const x3 = Math.cos(angle3) * outerRadius; 
            const y3 = Math.sin(angle3) * outerRadius;
            const x4 = Math.cos(angle4) * radius; 
            const y4 = Math.sin(angle4) * radius;
            
            if(i === 0) ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2); 
            ctx.lineTo(x3, y3); 
            ctx.lineTo(x4, y4);
          }
          ctx.closePath(); 
          
          // Fill gear
          ctx.fillStyle = gradient;
          ctx.fill();
          
          // Stroke gear outline
          ctx.strokeStyle = `rgba(255,255,255,${strokeOpacity})`;
          ctx.lineWidth = 1.8;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.stroke();
          
          // Draw center hub
          ctx.beginPath(); 
          ctx.arc(0, 0, innerRadius, 0, Math.PI*2);
          ctx.strokeStyle = `rgba(255,255,255,${strokeOpacity * 0.8})`;
          ctx.lineWidth = 1.2;
          ctx.stroke();
          
          // Add center dot
          ctx.beginPath();
          ctx.arc(0, 0, innerRadius * 0.3, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255,255,255,${strokeOpacity * 0.6})`;
          ctx.fill();
          
          ctx.restore();
        }
        
        function frame(animated){
          ctx.clearRect(0,0,w,h);
          if (animated) time += 0.008;
          
          // Enhanced gear positioning and sizing
          const gear1X = w * 0.28; 
          const gear1Y = h * 0.45; 
          const gear1Radius = Math.min(w, h) * 0.14;
          const gear2X = w * 0.72; 
          const gear2Y = h * 0.55; 
          const gear2Radius = Math.min(w, h) * 0.10;
          const gear3X = w * 0.5; 
          const gear3Y = h * 0.25; 
          const gear3Radius = Math.min(w, h) * 0.08;
          
          // Draw connection lines between gears
          ctx.strokeStyle = 'rgba(255,255,255,0.06)';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(gear1X, gear1Y);
          ctx.lineTo(gear2X, gear2Y);
          ctx.moveTo(gear1X, gear1Y);
          ctx.lineTo(gear3X, gear3Y);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Draw gears with proper mechanical ratios
          const baseRotation = animated ? time : 0.5;
          drawGear(gear1X, gear1Y, gear1Radius, 16, baseRotation, 0.18, 0.08);
          drawGear(gear2X, gear2Y, gear2Radius, 10, -baseRotation * 1.6, 0.16, 0.06); // 16/10 ratio
          drawGear(gear3X, gear3Y, gear3Radius, 8, baseRotation * 2, 0.14, 0.04); // 16/8 ratio
          
          if(!animated) return;
          
          // Animate sparkles for CAD/manufacturing effect
          sparkles.forEach(sparkle => {
            sparkle.phase += sparkle.speed;
            const opacity = sparkle.opacity * (0.5 + 0.5 * Math.sin(sparkle.phase));
            
            ctx.beginPath();
            ctx.fillStyle = `rgba(255,255,255,${opacity})`;
            ctx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Slowly drift sparkles
            sparkle.x += Math.sin(sparkle.phase * 0.1) * 0.1;
            sparkle.y += Math.cos(sparkle.phase * 0.15) * 0.1;
            
            // Reset if out of bounds
            if(sparkle.x < 0 || sparkle.x > w || sparkle.y < 0 || sparkle.y > h) {
              sparkle.x = Math.random() * w;
              sparkle.y = Math.random() * h;
            }
          });
        }
        
        function animate(){ 
          frame(true); 
          requestAnimationFrame(animate); 
        }
        
        resize();
        if (mediaReduce.matches){ 
          frame(false); 
        } else { 
          animate(); 
        }
        window.addEventListener('resize', resize);
      });
    })();

    // Dark mode toggle control
    const btn = document.getElementById('modeBtn');
    btn?.addEventListener('click', ()=>{
      const cur = getComputedStyle(document.documentElement).colorScheme;
      const next = cur === 'dark' ? 'light' : 'dark';
      document.documentElement.style.colorScheme = next;
      localStorage.setItem('mode', next);
    });

    // Scroll progress indicator
    const scrollProgress = document.getElementById('scrollProgress');
    if (scrollProgress) {
      function updateScrollProgress() {
        const scrollPercent = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
        scrollProgress.style.width = Math.min(scrollPercent, 100) + '%';
      }
      window.addEventListener('scroll', updateScrollProgress);
      updateScrollProgress(); // Initial call
    }

    // Performance optimization: pause animations when not visible
    const animationObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const canvas = entry.target.querySelector('canvas');
        if (canvas) {
          canvas.style.animationPlayState = entry.isIntersecting ? 'running' : 'paused';
        }
      });
    });

    document.querySelectorAll('.thumb').forEach(thumb => {
      animationObserver.observe(thumb);
    });
  </script>
</body>
</html>
